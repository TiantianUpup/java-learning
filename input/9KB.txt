vor区，survivor区中又有from区和to区.我们new出来的对象大家都知道是放在堆中，那具体放在堆中的
   哪个位置呢？其实new出来的对象一般都放在Eden区，那么为什么叫伊甸园区呢，伊甸园就是亚当夏娃住的
   地方，不就是造人的地方么？所以我们new出来的对象就是放在这里的，那当Eden区满了之后呢？假设我们
   给对分配600M内存，这个是可以通过参数调节的，我们后文再讲。那么老年代默认是占2/3的，也就是差不
   多400M，那年轻代就是200M，Eden区160M，Survivor区40M。GC一个程序只要在运行，那么就不会不停
   的new对象，那么总有一刻Eden区会放满，那么一旦Eden区被放满之后，虚拟机会干什么呢？没错，就是gc
   ，不过这里的gc属于minor gc，就是垃圾收集，来收集垃圾对象并清理的，那么什么是垃圾对象
   呢？好比我们上面说的math对象，我们假设我们是一个web应用程序，main线程执行完之后程序不
   会结束，但是main方法结束了，那么main()方法栈帧会被释放，局部变量会被释放，但是局部变量
   对应的堆中的对象还是依然存在的，但是又没有指针指向它，那么它就是一个垃圾对象，那就应该被
   回收掉了，之后如果还会new Math对象，也不会用这个之前的了，因为已经无法找到它了，如果留
   着这个对象只会占用内存，显然是不合适的。这里就涉及到了一个GC Root根以及可达性分析算法
   的概念，也是面试偶尔会被问到的。可达性分析算法是将GC Roots对象作为起点，从这些起点开始
   向下搜索引用的对象，找到的对象都标记为非垃圾对象，其余未标记的都是垃圾对象。那么
   GC Roots根对象又是什么呢，GC Roots根就是判断一个对象是否可以回收的依据，只要能通
   过GC Roots根向下一直搜索能搜索到的对象，那么这个对象就不算垃圾对象，而可以作为GC
    Roots根的有线程栈的本地变量，静态变量，本地方法栈的变量等等，说白了就是找到和根节
    点有联系的对象就是有用的对象，其余都认为是垃圾对象来回收。经历了第一次minor gc后
    ，没有被清理的对象就会被移到From区，如上图。上面在说对象组成的时候有写到，在对象
    头的Mark Word中有存储GC分代年龄，一个对象每经历一次gc，那么它的gc分代年龄就会
    +1，如上图。那么如果第二次新的对象又把Eden区放满了，那么又会执行minor gc，但是
    这次会连着From区一起gc，然后将Eden区和From区存活的对象都移到To区域，对象头中
    分代年龄都+1，如上图。那么当第三次Eden区又满的时候，minor gc就是回收Eden区和
    To区域了，TEden区和To区域还活着的对象就会都移到From区，如上图。说白了就是Sur
    vivor区中总有一块区域是空着的，存活的对象存放是在From区和To区轮流存放，也就是
    互相复制拷贝，这也就是垃圾回收算法中的复制-回收算法。如果一个对象经历了一个限值
    15次gc的时候，就会移至老年代。那如果还没有到限值，From区或者To区域也放不下了，就
    会直接挪到老年代，这只是举例了两种常规规则，还有其他规则也是会把对象存放至老年代的
    。那么随着应用程序的不断运行，老年代最终也是会满的，那么此时也会gc，此时的gc就是F
    ull gc了。GC案例下面我们通过一个简单的演示案例来更加清楚的了解GC。public class HeapTest {
       byte[] a = new byte[1024*100];
       public static void main(String[] args) throws InterruptedException {
           ArrayList<HeapTest> heapTest = new ArrayList<>();
           while(true) {
               heapTest.add(new HeapTest());
               Thread.sleep(10);
           }
       }
   }这块
   vor区，survivor区中又有from区和to区.我们new出来的对象大家都知道是放在堆中，那具体放在堆中的
      哪个位置呢？其实new出来的对象一般都放在Eden区，那么为什么叫伊甸园区呢，伊甸园就是亚当夏娃住的
      地方，不就是造人的地方么？所以我们new出来的对象就是放在这里的，那当Eden区满了之后呢？假设我们
      给对分配600M内存，这个是可以通过参数调节的，我们后文再讲。那么老年代默认是占2/3的，也就是差不
      多400M，那年轻代就是200M，Eden区160M，Survivor区40M。GC一个程序只要在运行，那么就不会不停
      的new对象，那么总有一刻Eden区会放满，那么一旦Eden区被放满之后，虚拟机会干什么呢？没错，就是gc
      ，不过这里的gc属于minor gc，就是垃圾收集，来收集垃圾对象并清理的，那么什么是垃圾对象
      呢？好比我们上面说的math对象，我们假设我们是一个web应用程序，main线程执行完之后程序不
      会结束，但是main方法结束了，那么main()方法栈帧会被释放，局部变量会被释放，但是局部变量
      对应的堆中的对象还是依然存在的，但是又没有指针指向它，那么它就是一个垃圾对象，那就应该被
      回收掉了，之后如果还会new Math对象，也不会用这个之前的了，因为已经无法找到它了，如果留
      着这个对象只会占用内存，显然是不合适的。这里就涉及到了一个GC Root根以及可达性分析算法
      的概念，也是面试偶尔会被问到的。可达性分析算法是将GC Roots对象作为起点，从这些起点开始
      向下搜索引用的对象，找到的对象都标记为非垃圾对象，其余未标记的都是垃圾对象。那么
      GC Roots根对象又是什么呢，GC Roots根就是判断一个对象是否可以回收的依据，只要能通
      过GC Roots根向下一直搜索能搜索到的对象，那么这个对象就不算垃圾对象，而可以作为GC
       Roots根的有线程栈的本地变量，静态变量，本地方法栈的变量等等，说白了就是找到和根节
       点有联系的对象就是有用的对象，其余都认为是垃圾对象来回收。经历了第一次minor gc后
       ，没有被清理的对象就会被移到From区，如上图。上面在说对象组成的时候有写到，在对象
       头的Mark Word中有存储GC分代年龄，一个对象每经历一次gc，那么它的gc分代年龄就会
       +1，如上图。那么如果第二次新的对象又把Eden区放满了，那么又会执行minor gc，但是
       这次会连着From区一起gc，然后将Eden区和From区存活的对象都移到To区域，对象头中
       分代年龄都+1，如上图。那么当第三次Eden区又满的时候，minor gc就是回收Eden区和
       To区域了，TEden区和To区域还活着的对象就会都移到From区，如上图。说白了就是Sur
       vivor区中总有一块区域是空着的，存活的对象存放是在From区和To区轮流存放，也就是
       互相复制拷贝，这也就是垃圾回收算法中的复制-回收算法。如果一个对象经历了一个限值
       15次gc的时候，就会移至老年代。那如果还没有到限值，From区或者To区域也放不下了，就
       会直接挪到老年代，这只是举例了两种常规规则，还有其他规则也是会把对象存放至老年代的
       。那么随着应用程序的不断运行，老年代最终也是会满的，那么此时也会gc，此时的gc就是F
       ull gc了。GC案例下面我们通过一个简单的演示案例来更加清楚的了解GC。public class HeapTest {
          byte[] a = new byte[1024*100];
          public static void main(String[] args) throws InterruptedException {
              ArrayList<HeapTest> heapTest = new ArrayList<>();
              while(true) {
                  heapTest.add(new HeapTest());
                  Thread.sleep(10);
              }
          }
      }这块